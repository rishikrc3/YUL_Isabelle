theory BasicSyntax
  imports Main Proof
begin

type_synonym var_name = string
type_synonym val_name = nat
type_synonym state = "var_name \<Rightarrow> val_name"
type_synonym word = nat  
definition empty_state :: state where  "empty_state = (\<lambda>_. 0)"  

definition add_variable :: "state \<Rightarrow> var_name \<Rightarrow> val_name \<Rightarrow> state" where
  "add_variable old_state var_name new_value = old_state(var_name :=  new_value)"

(*Unit Tests *)

lemma "empty_state ''x'' = 0"
  by (simp add: empty_state_def)


lemma "add_variable empty_state ''x'' 5 ''x'' =  5"
  by (simp add: add_variable_def empty_state_def)


lemma "add_variable empty_state ''x'' 5 ''y'' = 0"  
  by (simp add: add_variable_def empty_state_def)

definition yadd   :: "word \<Rightarrow> word \<Rightarrow> word"   where "yadd x y \<equiv> x + y"

(*Simple Yul Program*)
 
definition simple_program  where "simple_program = 
( let s = add_variable empty_state ''i'' 0 in
let s' = add_variable s ''i'' ( yadd(s ''i'')(1)) in s') "

value "simple_program ''i''"

(*Expression*)




end
